# YT Viewer

```elixir
Mix.install([
  {:kino, "~> 0.9.1"},
  {:floki, "~> 0.35.2"},
  {:youtube_organizer, path: Path.join([__DIR__, "youtube_organizer"])}
])
```

## Section

```elixir
yt_api_key =
  "~/.keys/yt_api_key.txt"
  |> Path.expand()
  |> File.read!()
  |> String.trim()

"Loaded api key"
```

```elixir
defmodule YTOrg.Channels do
  require HTTPoison

  def fetch_latest_videos(channel_names, api_key) when is_list(channel_names) do
    channel_names
    |> Enum.map(&fetch_latest_videos(&1, api_key))
    |> Enum.concat()
    |> Enum.sort_by(& &1.published_at)
    |> Enum.reverse()
  end

  def fetch_latest_videos(channel_name, api_key) do
    channel_name
    |> fetch_latest_video_data(api_key)
    |> Enum.map(&YTOrg.YoutubeRecordParser.parse_video/1)
  end

  @doc """
  fetch asynchronously
  """
  def afetch_latest_videos(channel_names, api_key) when is_list(channel_names) do
    channel_names
    |> Enum.map(fn channel_name -> Task.async(fetch_latest_videos(channel_name, api_key)) end)
    |> Enum.map(&Task.await/1)
    |> Enum.concat()
    |> Enum.sort_by(& &1.published_at)
    |> Enum.reverse()
  end

  def fetch_latest_video_data(channel_name, api_key) do
    {:ok, channel_id} = fetch_channel_id(channel_name, api_key)

    url =
      "https://www.googleapis.com/youtube/v3/search?part=snippet&type=video&maxResults=10&order=date&channelId=#{channel_id}&key=#{api_key}"

    with {:ok, response} <- HTTPoison.get(url),
         {:ok, %{"items" => videos}} <- response |> Map.get(:body) |> Poison.decode() do
      videos
    else
      err -> err
    end
  end

  def fetch_channel_id(channel_name, api_key) do
    url =
      "https://www.googleapis.com/youtube/v3/search?part=snippet&type=channel&maxResults=1&q=#{channel_name}&key=#{api_key}"

    case HTTPoison.get(url) do
      {:ok, response} ->
        response
        |> Map.get(:body)
        |> Poison.decode()
        |> case do
          {:ok, %{"items" => [%{"id" => %{"channelId" => channel_id}} | _]}} ->
            {:ok, channel_id}

          _ ->
            {:error, :channel_not_found}
        end

      {:error, %HTTPoison.Error{} = err} ->
        IO.inspect(err)
    end
  end
end
```

```elixir
defmodule YTOrg.KinoHelpers do
  def get_link_md(%YTOrg.YoutubeVideo{title: title, url: url}) do
    "[#{title}](#{url})"
  end

  def get_link_kino(%YTOrg.YoutubeVideo{} = vid) do
    vid
    |> get_link_md()
    |> Kino.Markdown.new()
  end

  def get_thumbnail_url(%YTOrg.YoutubeVideo{thumbnails: thumbnails}, size \\ "medium") do
    thumbnails[size]["url"]
  end

  def maybe_add_preceding_link_kino(layout, vid = %YTOrg.YoutubeVideo{}) do
    closest_vid_kino =
      vid
      |> get_link_kino()

    Kino.Layout.grid([closest_vid_kino, layout])
  end

  def maybe_add_preceding_link_kino(layout, nil) do
    layout
  end
end
```

```elixir
defmodule YTOrg.YoutubeKinoTiler do
  defstruct [:format_tile]

  def new() do
    %YTOrg.YoutubeKinoTiler{format_tile: &make_basic_tile_kino/2}
  end

  def new(format_tile) do
    %YTOrg.YoutubeKinoTiler{format_tile: format_tile}
  end

  def get_video_tile(kt, video) do
    channel = video.channel_title |> Kino.Markdown.new()
    image = "![](#{video |> YTOrg.KinoHelpers.get_thumbnail_url()})" |> Kino.Markdown.new()
    title_with_link = video |> YTOrg.KinoHelpers.get_link_md() |> Kino.Markdown.new()
    video |> kt.format_tile.([image, channel, title_with_link])
  end

  def make_basic_tile_kino(_video, inputs) do
    Kino.Layout.grid(inputs, boxed: true)
  end

  def make_tile_kino_with_additional_fields(fields) do
    fn video, inputs ->
      field_values =
        for field <- fields do
          field_value = video |> Map.get(field)
          convert_field_to_markdown(field_value)
        end

      all_inputs = inputs ++ field_values
      Kino.Layout.grid(all_inputs, boxed: true)
    end
  end

  def convert_field_to_markdown(%DateTime{} = dt) do
    dt |> inspect() |> Kino.Markdown.new()
  end

  def convert_field_to_markdown(v), do: v |> Kino.Markdown.new()
end
```

```elixir
alias YTOrg.YoutubeKinoTiler
basic_tiler = YoutubeKinoTiler.new()
```

```elixir
urls = ["https://www.youtube.com/@jamesbriggs"]
```

```elixir
example_videos = YTOrg.Channels.fetch_latest_videos("samwitteveenai", yt_api_key)
[example_video | _] = example_videos
```

```elixir
example_video |> Map.get(:id)
```

```elixir
basic_tiler |> YTOrg.YoutubeKinoTiler.get_video_tile(example_video)
```

```elixir
selected_youtubers = ["samwitteveenai", "jamesbriggs", "DataIndependent"]
```

```elixir
tiler =
  YoutubeKinoTiler.new(
    YoutubeKinoTiler.make_tile_kino_with_additional_fields([:published_at, :description])
  )
```

```elixir
selected_latest_videos =
  YTOrg.Channels.fetch_latest_videos(
    selected_youtubers,
    yt_api_key
  )
```

```elixir
sorted_videos =
  selected_latest_videos
  |> Enum.sort(&(DateTime.compare(&1.published_at, &2.published_at) != :lt))

video_tiles =
  for vid <- sorted_videos do
    tiler |> YoutubeKinoTiler.get_video_tile(vid)
  end

video_tiles |> Kino.Layout.grid(columns: 3)
```

## Parsing subscriptions

It is notoriously hard to get an overview of subbed channels.

We're going to tackle that. First let's extract subs from youtube's left panel that shows subs.

```elixir
subs_path = __ENV__.file |> Path.dirname() |> Path.join("assets/yt_subs.html")
{:ok, subs_html} = subs_path |> File.read!() |> Floki.parse_document()
```

```elixir
defmodule YTOrg.YoutubeSubsExtractor do
  def extract_subs(subs_html) do
    channel_elems =
      subs_html
      |> Floki.find(".yt-simple-endpoint")

    channel_elems |> Enum.flat_map(&maybe_get_sub/1)
  end

  def maybe_get_sub({"a", elems, _}) do
    with {:ok, sub_data} <- get_title_and_link(elems) do
      [sub_data]
    else
      _ -> []
    end
  end

  def get_title_and_link([]), do: {:error, nil}
  def get_title_and_link([_]), do: {:error, nil}

  def get_title_and_link([{"title", title}, {"href", href}]) do
    {:ok,
     %{
       channel_name: title,
       channel_link: "https://www.youtube.com#{href}",
       fetchable_name: href |> String.replace("/@", "")
     }}
  end

  def get_title_and_link([_ | rest]), do: get_title_and_link(rest)
end
```

```elixir
alias YTOrg.YoutubeSubsExtractor
```

```elixir
sub_data = subs_html |> YoutubeSubsExtractor.extract_subs()
sub_data |> Enum.count()
```

Well, no wonder I can't wrap my head around over 300 subs.

```elixir
sub_data
```

Benchmark async fetching

WARNING: this code looks like it was called multiple times

<!-- livebook:{"force_markdown":true} -->

```elixir
{time_to_fetch, _} = :timer.tc(fn -> YTOrg.Channels.fetch_latest_videos(
  selected_youtubers,
  yt_api_key
) end
)

time_to_fetch / 1000000
```
